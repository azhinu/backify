<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8">
    <title>Backify</title>

    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.2/underscore-min.js"></script>
    <link href='https://fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic&subset=latin,latin-ext'
          rel='stylesheet' type='text/css'>

    <style type='text/css'>
        body {
            padding: 0;
            margin: 0;
            font-family: 'Lato', sans-serif;
            background: url(./gplaypattern.png) repeat;
            background-size: 188px 178px;
        }

        .container {
            width: 640px;
            margin-left: auto;
            margin-right: auto;
        }

        .footer {
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        .heading {
            color: #444;
            font-size: 24px;
            background-color: rgba(255, 255, 255, 0.9);
            border-bottom: solid 1px #eaeaea;
            width: 100%;
            z-index: 500;
            padding: 12px;
        }

        .button-main {
            font-size: 18px;
            font-weight: 600;
            line-height: 1.5;
            color: #fff;
            background-color: #2ebd59;
            display: inline-block;
            margin-bottom: 0;
            text-align: center;
            vertical-align: middle;
            cursor: pointer;
            background-image: none;
            border: 1px solid transparent;
            white-space: nowrap;
            border-radius: 500px;
            padding: 12px 47px 8px;
            border-width: 0;
            letter-spacing: 1.2px;
            min-width: 130px;
            text-transform: uppercase;
            white-space: normal;
            margin: 0 0 1em;
        }

        .button-main:disabled {
            background: #dddddd;
        }

        .button-big {
            margin-left: 150px;
        }

        .button-medium {
            margin-left: 80px;
        }

        .title-bold {
            font-weight: bold;
            font-size: 44px;
        }

        .title-light {
            font-weight: 300;
            color: #555;
            font-size: 44px;
        }

        .title-medium {
            font-weight: bold;
            font-size: 18px;
        }

        .progress-bar {
            width: 0%;
            background-color: #86e01e;
            position: relative;
            height: 16px;
            border-radius: 4px;
            -webkit-transition: 0.4s linear;
            -moz-transition: 0.4s linear;
            -o-transition: 0.4s linear;
            transition: 0.4s linear;
            -webkit-transition-property: width, background-color;
            -moz-transition-property: width, background-color;
            -o-transition-property: width, background-color;
            transition-property: width, background-color;
            -webkit-box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.25), inset 0 1px rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.25), inset 0 1px rgba(255, 255, 255, 0.1);
        }

        .progress {
            width: 100%;
            padding: 4px;
            margin-top: 10px;
        }

        .link {
            font-size: 14px;
            padding: 5px 15px;
            color: #121F59;
            text-decoration: none;
        }

        .link:hover {
            color: #A2C852;
        }
    </style>
</head>
<body>
<a href="https://github.com/secuvera/SpotMyBackup/"><img style="position: absolute; top: 0; left: 0; border: 0;"
                                                         src="https://camo.githubusercontent.com/121cd7cbdc3e4855075ea8b558508b91ac463ac2/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67"
                                                         alt="Fork me on GitHub"
                                                         data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png"></a>

<div class="container">
    <div class="heading">
        <span class="title-bold">Backify</span>
        <br/>
        <br/>
        <div id="pnlLoggedOut">
            <span><b>Export</b> your playlists and tracks setup into a file by a single click. <b>Import</b> the file to restore your setup at any time.</span>
            <br/>
            <br/>
            <button id="login" class="button-main button-big">Login with Spotify</button>
        </div>
    </div>
    <div id="pnlLoadingAccount" style="font-size: 16px; display: none;" class="heading">
        <div class="title-medium">Account: <span id="userName"></span></div>
        <br/>
        <div id="loadingArtists"></div>
        <div id="loadingPlaylists"></div>
        <div id="loadingTracks"></div>
        <br/>
        <div id="loadingTitle"></div>
    </div>
    <div id="pnlAction" style="overflow: hidden; display: none;">
        <br/>
        <div style="width: 50%; float: left;">
            <button id="btnExport" class="button-main button-medium">Export</button>
        </div>
        <div style="width: 50%; float: left;">
            <input style="display:none;" type="file" id="fileImport"/>
            <button id="btnImport" class="button-main button-medium">Import</button>
        </div>
    </div>
    <div id="pnlFileInfo" style="font-size: 16px; overflow: hidden; display: none;" class="heading">
        <div class="title-medium">File: <span id="fileName"></span></div>
        <br/>
        <div id="fileArtists"></div>
        <div id="filePlaylists"></div>
        <div id="fileTracks"></div>
    </div>
    <div id="pnlUpload" style="font-size: 16px; overflow: hidden; display: none;" class="heading">
        <div class="title-medium">Importing new playlists and tracks</div>
        <br/>
        <div><span>Processed artists: </span><span id="artistStep"></span>/<span id="artistTotal"></span></div>
        <div><span>Processed playlists: </span><span id="playlistStep"></span>/<span id="playlistTotal"></span></div>
        <div><span>Processed tracks: </span><span id="trackStep"></span>/<span id="trackTotal"></span></div>
        <br/>
        <div id="globalStep"></div>
        <div class="progress">
            <div id="progressBar" class="progress-bar" style="display: none;"></div>
        </div>
    </div>
</div>
<div class="footer">
    <div class="container"
         style="background-color: rgba(255,255,255,0.9); border-bottom: solid 1px #eaeaea; overflow: hidden;">
        <a href="https://github.com/secuvera/SpotMyBackup/wiki" style="float: left;" class="link">Wiki</a>
        <a href="https://www.secuvera.de/unternehmen/impressum/" style="float: right;" class="link">Impress</a>
    </div>
</div>
<script type='text/javascript'>


    let spotifyConfig;

    let authWindow = null;
    let token = null;
    let collections = {};
    let userId;
    let email;

    let isImporting = false;
    let isExporting = false;
    let globalStep = "";
    let playlistStep = 0;
    let playlistTotal = 0;
    let trackStep = 0;
    let trackTotal = 0;
    let artistStep = 0;
    let artistTotal = 0;

    let playlistQueue = [];
    let savedQueue = [];

    let makingChanges = false;

    function init() {
        toggleLoginButton();
        loadConfig(function () {
            window.addEventListener("message", authCallback, false);
            bindControls();
            refreshProgress();
            toggleLoginButton();
        });
    }

    function toggleLoginButton() {
        $('#login').prop('disabled', function (i, v) {
            return !v;
        });
    }

    function toggleExportButton() {
        $('#btnExport').prop('disabled', function (i, v) {
            return !v;
        });
    }

    function loadFile() {
        $('#fileImport').trigger('click');
    }

    function loadConfig(callback) {
        XHR('config.json', function (response) {
            spotifyConfig = JSON.parse(response).spotifyConfig;
            callback();
        });
    }

    function bindControls() {
        $('#login').click(login);
        $('#btnImport').click(loadFile);
        $('#btnExport').click(download);
        $('#fileImport').change(readFile);
    }

    function handleAuth(accessToken) {
        token = accessToken;
        $.ajax({
            url: 'https://api.spotify.com/v1/me',
            headers: {
                'Authorization': 'Bearer ' + accessToken
            },
            success: function (response) {
                userId = response.id.toLowerCase();
                email = response.email.toLowerCase();

                $('#userName').html(email);
                $('#pnlLoggedOut').hide();

                refreshTrackData(function () {
                    // Check for all the data read
                    // If user has no music/artists in account disable export button
                    if (isEmpty(collections.playlists) &&
                        isEmpty(collections.saved) &&
                        isEmpty(collections.artists)) {
                        toggleExportButton();
                    }
                    $('#pnlAction').show();
                });
            }
        });
    }

    function refreshTrackData(callback) {
        if (!isExporting && !isImporting) {
            isExporting = true;
            resetCounter();
            $('#pnlLoadingAccount').show();
            $('#loadingTitle').html('Please wait. Loading your playlists ...');
            refreshPlaylist(function () {
                $('#loadingTitle').html('Please wait. Loading your tracks ...');
                refreshMyMusicTracks(function () {
                    $('#loadingTitle').html('Please wait. Loading your artists ...');
                    refreshFollowedArtists(function () {
                        $('#loadingTitle').html('Finished loading, you now might want to export or import.');
                        isExporting = false;
                        callback();
                    });
                });
            });
        }
    }

    function resetCounter() {
        globalStep = '';
        playlistStep = 0;
        playlistTotal = 0;
        trackStep = 0;
        trackTotal = 0;
    }

    function refreshProgress() {
        $('#globalStep').html(globalStep);
        $('#playlistStep').html(playlistStep);
        $('#playlistTotal').html(playlistTotal);
        $('#trackStep').html(trackStep);
        $('#trackTotal').html(trackTotal);
        $('#artistStep').html(artistStep);
        $('#artistTotal').html(artistTotal);
        let progress = 0;
        if (trackTotal > 0) {
            progress = Math.floor(((trackStep / trackTotal) * 100));
        }
        if (artistTotal > 0) {
            progress = Math.floor((progress + Math.floor(((artistStep / artistTotal) * 100))) / 2);
        }
        $('#progressBar').css('width', progress + '%');
        if (typeof collections !== 'undefined' && !makingChanges) {
            let set = collectionProperties(collections);
            $('#loadingPlaylists').html("" + set.playlistCount + " playlists");
            $('#loadingTracks').html("" + set.trackCount + " tracks");
            $('#loadingArtists').html("" + set.artistCount + " artists");
        }
        if (typeof importColl !== 'undefined') {
            let set2 = collectionProperties(importColl);
            $('#filePlaylists').html("" + set2.playlistCount + " playlists");
            $('#fileTracks').html("" + set2.trackCount + " tracks");
            $('#fileArtists').html("" + set2.artistCount + " artists");

        }
        setTimeout(refreshProgress, 100);
    }

    function login() {
        let width = 480, height = 640;
        let left = (screen.width / 2) - (width / 2);
        let top = (screen.height / 2) - (height / 2);

        let set = {
            client_id: spotifyConfig.client_id,
            redirect_uri: spotifyConfig.redirect_uri,
            scope: spotifyConfig.scope,
            response_type: spotifyConfig.response_type,
            show_dialog: spotifyConfig.show_dialog
        };
        authWindow = window.open(
            "https://accounts.spotify.com/authorize?" + urlEncodeSet(set),
            "Spotify",
            'menubar=no,location=no,resizable=no,scrollbars=no,status=no, width=' + width + ', height=' + height + ', top=' + top + ', left=' + left
        );
    }

    function authCallback(event) {
        if (event.origin !== spotifyConfig.uri) {
            return;
        }
        if (authWindow) {
            authWindow.close();
        }
        if (event.data) {
            handleAuth(event.data);
        }
    }

    function urlEncodeSet(set) {
        let comps = [];
        for (let i in set) {
            if (set.hasOwnProperty(i)) {
                comps.push(encodeURIComponent(i) + "=" + encodeURIComponent(set[i]));
            }
        }
        return comps.join("&");
    }

    function download() {
        let json = JSON.stringify(collections);
        let d = new Date();
        let time = '@' + d.getFullYear() + '_' + (d.getMonth() + 1) + '_' + d.getDate();
        let emailWithoutDomain = email.substring(0, email.lastIndexOf("@"));
        let filename = emailWithoutDomain + time + '.json';
        let pom = document.createElement('a');
        pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(json));
        pom.setAttribute('download', filename);

        if (document.createEvent) {
            let event = document.createEvent('MouseEvents');
            event.initEvent('click', true, true);
            pom.dispatchEvent(event);
        }
        else {
            pom.click();
        }
    }

    function readFile(evt) {
        //Retrieve the first (and only!) File from the FileList object
        let f = evt.target.files[0];

        if (f) {
            $('#fileName').html(f.name);

            let r = new FileReader();
            r.onload = function (e) {
                let json = e.target.result;

                importColl = JSON.parse(json);

                $('#pnlAction').hide();
                $('#pnlFileInfo').show();
                $('#pnlUpload').show();

                compareEverything();
            };
            r.readAsText(f);
        } else {
            alert("Failed to load file");
        }
    }

    function collectionProperties(coll) {
        return {
            playlistCount: collPlaylistCount(coll),
            trackCount: collTrackCount(coll),
            artistCount: collArtistCount(coll)
        };
    }

    function collTrackCount(coll) {
        let count = 0;
        let keys = _.keys(coll.playlists);
        $.each(keys, function (index, value) {
            count += coll.playlists[value].tracks.length;
        });
        if (coll.saved) {
            count += coll.saved.length;
        }
        return count;
    }

    function collPlaylistCount(coll) {
        let keys = _.keys(coll.playlists);
        return keys.length;
    }

    function collArtistCount(coll) {
        let keys = _.keys(coll.artists);
        return keys.length;
    }

    function compareEverything() {
        if (!isImporting && !isExporting) {
            isImporting = true;
            makingChanges = true;
            resetCounter();

            savedQueue = [];
            playlistQueue = [];
            artistQueue = [];

            globalStep = "Uploading";
            if (typeof importColl !== 'undefined') {

                playlistTotal = collPlaylistCount(importColl);

                // compare artists
                globalStep = "Comparing artists";
                compareArtists(importColl.artists, collections.artists, addToFollowing);

                // compare saved
                globalStep = "Comparing saved tracks";
                compareIdTracks(importColl.saved, collections.saved, addToSaved);

                // compare playlists
                let playlistNames = _.keys(importColl.playlists);
                globalStep = "Comparing playlists";
                handlePlaylistCompare(playlistNames.reverse(), function () {
                    handleUpload();
                });
            }
        }
    }

    function handleUpload() {

        // calculate track differences
        trackDiff = savedQueue.length + playlistQueue.length;
        trackTotal = Math.max(collTrackCount(importColl), trackDiff);
        trackStep = trackTotal - trackDiff;
        // calculate artist differences
        artistTotal = Math.max(collArtistCount(importColl), artistQueue.length);
        artistStep = artistTotal - artistQueue.length;

        console.log('Artist total -> ', artistTotal);
        console.log('Artist queue -> ', artistQueue);

        if (artistTotal > 0) {
            $('#progressBar').show();
            globalStep = "Following artists";
            handleArtistRequests(artistQueue.reverse(), function () {
                globalStep = "Finished following artists";
                artistTotal = artistStep;
            })
        }
        else if (trackTotal > 0) {
            $('#progressBar').show();
            globalStep = "Uploading tracks";
            handleSavedRequests(savedQueue.reverse(), function () {
                handlePlaylistRequests(playlistQueue.reverse(), function () {
                    globalStep = "Finished everything";
                    trackTotal = trackStep;
                });
            });
        } else {
            globalStep = "No new tracks or artists found in import";
        }

        isImporting = false;

    }

    function handlePlaylistCompare(names, callback) {
        let name = names.pop();
        if (!name) {
            callback();
            return;
        }
        makeSurePlaylistExists(name, function (proceed) {
            if (proceed) {
                let playlistId = collections.playlists[name].id;
                compareUriTracks(importColl.playlists[name].tracks, collections.playlists[name].tracks, function (uri) {
                    addToPlaylist(playlistId, uri);
                });
            }
            handlePlaylistCompare(names, callback);
        });
    }

    function addToPlaylist(playlistId, trackUri) {
        playlistQueue.push('https://api.spotify.com/v1/users/' + userId + '/playlists/' + playlistId + '/tracks?uris=' + encodeURIComponent(trackUri));
    }

    function makeSurePlaylistExists(name, callback) {
        playlistStep += 1;
        if (name in collections.playlists) {
            callback(true);
            return;
        }
        let set = {name: name, public: "true"};
        $.ajax({
            method: "POST",
            url: 'https://api.spotify.com/v1/users/' + userId + '/playlists',
            data: JSON.stringify(set),
            contentType: 'application/json',
            headers: {
                'Authorization': 'Bearer ' + token
            },
            success: function (response) {
                collections.playlists[name] = {
                    name: name,
                    href: response.tracks.href,
                    id: response.id,
                    tracks: []
                };
                callback(true);
            },
            fail: function () {
                callback(false);
            }
        });
    }

    function handleArtistRequests(arr, callback) {
        let url = arr.pop();
        if (url) {
            artistStep += 1;
            console.log('Artist step -> ', artistStep);
            $.ajax({
                method: "PUT",
                url: url,
                headers: {
                    'Authorization': 'Bearer ' + token
                },
                success: function () {
                },
                fail: function (jqXHR, textStatus, errorThrown) {
                    console.log(errorThrown);
                }
            })
                .always(function () {
                    handleArtistRequests(arr, callback);
                });
        } else {
            callback();
        }
    }

    function handleSavedRequests(arr, callback) {
        let url = arr.pop();
        if (url) {
            trackStep += 1;
            $.ajax({
                method: "PUT",
                url: url,
                headers: {
                    'Authorization': 'Bearer ' + token
                },
                success: function () {
                },
                fail: function (jqXHR, textStatus, errorThrown) {
                    console.log(errorThrown);
                }
            })
                .always(function () {
                    handleSavedRequests(arr, callback);
                });
        } else {
            callback();
        }
    }

    function handlePlaylistRequestsWithTimeout(arr, callback, timeout) {
        setTimeout(function () {
            handlePlaylistRequests(arr, callback)
        }, timeout);
    }

    function handlePlaylistRequests(arr, callback) {
        let url = arr.pop();
        if (url) {
            trackStep += 1;
            $.ajax({
                method: "POST",
                url: url,
                contentType: 'application/json',
                headers: {
                    'Authorization': 'Bearer ' + token
                },
                fail: function (jqXHR, textStatus, errorThrown) {
                    console.log('Track URI not found. Probably local file...');
                }
            })
                .always(function () {
                    handlePlaylistRequestsWithTimeout(arr, callback, spotifyConfig.slowdown_import);
                })
        } else {
            callback();
        }
    }

    function addToSaved(id) {
        savedQueue.push('https://api.spotify.com/v1/me/tracks?ids=' + id);
    }

    function addToFollowing(id) {
        artistQueue.push('https://api.spotify.com/v1/me/following?type=artist&ids=' + id);
    }

    function compareUriTracks(imported, stored, addCallback) {
        $.each(imported, function (index, value) {
            let found = false;
            $.each(stored, function (index2, value2) {
                if (value.uri === value2.uri) {
                    found = true;
                }
            });
            if (!found) {
                addCallback(value.uri);
            }
        });
    }

    function compareIdTracks(imported, stored, addCallback) {
        $.each(imported, function (index, value) {
            let found = false;
            $.each(stored, function (index2, value2) {
                if (value.id === value2.id) {
                    found = true;
                }
            });
            if (!found) {
                addCallback(value.id);
            }
        });
    }

    function compareArtists(imported, stored, addCallback) {
        $.each(imported, function (index, value) {
            let found = false;
            $.each(stored, function (index2, value2) {
                if (value.id === value2.id) {
                    found = true;
                }
            });
            if (!found) {
                addCallback(value.id);
            }
        });
    }

    function refreshMyMusicTracks(callback) {
        collections.saved = [];
        playlistStep += 1;
        loadTrackChunks('https://api.spotify.com/v1/me/tracks', collections.saved, callback);
    }

    function loadTrackChunksWithTimeout(url, arr, callback, timeout) {
        setTimeout(function () {
            loadTrackChunks(url, arr, callback)
        }, timeout);
    }

    function loadTrackChunks(url, arr, callback) {
        $.ajax({
            url: url,
            headers: {
                'Authorization': 'Bearer ' + token
            },
            success: function (data) {
                if (!data) return;
                if ('items' in data) {
                    $.each(data.items, function (index, value) {
                        if (value.track !== null) {
                            arr.push({id: value.track.id, uri: value.track.uri});
                        } else {
                            console.log("track is null", value);
                        }
                    });
                } else {
                    arr.push({id: data.track.id, uri: data.track.uri});
                }
                if (data.next) {
                    loadTrackChunksWithTimeout(data.next, arr, callback, spotifyConfig.slowdown_export);
                } else {
                    callback();
                }
            }
        });
    }

    function refreshPlaylist(callback) {
        collections.playlists = {};
        let playlists = [];
        loadPlaylistChunks('https://api.spotify.com/v1/me/playlists', playlists, function () {
            handlePlaylistTracks(playlists, collections.playlists, callback);
        });
    }

    function loadPlaylistChunks(url, arr, callback) {
        $.ajax({
            url: url,
            headers: {
                'Authorization': 'Bearer ' + token
            },
            success: function (data) {
                if (!data) return;
                if ('items' in data) {
                    $.each(data.items, function (index, value) {
                        if (value.tracks && value.tracks.href) {
                            arr.push({
                                name: value.name,
                                href: value.tracks.href,
                                id: value.id,
                                tracks: []
                            });
                        }
                    });
                } else {
                    if (data.tracks && data.tracks.href) {
                        arr.push({
                            name: data.name,
                            href: data.tracks.href,
                            id: value.id,
                            tracks: []
                        });
                    }
                }
                if (data.next) {
                    loadPlaylistChunks(data.next, arr, callback);
                } else {
                    callback();
                }
            }
        });
    }

    function handlePlaylistTracks(arr, result, callback) {
        let item = arr.pop();
        if (!item) {
            return callback();
        }
        playlistStep += 1;
        item.tracks = [];
        loadTrackChunks(item.href, item.tracks, function () {
            delete item.href;
            result[item.name] = item;
            if (arr.length === 0) {
                callback();
            } else {
                handlePlaylistTracks(arr, result, callback);
            }
        });
    }

    function refreshFollowedArtists(callback) {
        collections.artists = [];
        loadArtistChunks('https://api.spotify.com/v1/me/following?type=artist', collections.artists, callback);
    }

    function loadArtistChunks(url, arr, callback) {
        $.ajax({
            url: url,
            headers: {
                'Authorization': 'Bearer ' + token
            },
            success: function (data) {
                if (!data.artists) return;
                if ('items' in data.artists) {
                    $.each(data.artists.items, function (index, value) {
                        if (value.id !== null && value.uri !== null) {
                            arr.push({id: value.id, uri: value.uri});
                        } else {
                            console.log("artist is null", value);
                        }
                    });
                } else {
                    arr.push({id: data.artists.id, uri: data.artists.uri});
                }

                if (data.next) {
                    loadArtistChunks(data.artists.next, arr, callback);
                } else {
                    callback();
                }
            }
        });
    }

    window.onload = function () {
        if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
            // MSIE
            $('#pnlLoggedOut').html('Please use Firefox or Chrome, due to a bug in Internet Explorer');
        } else {
            init();
        }
    }

</script>
</body>
</html>
